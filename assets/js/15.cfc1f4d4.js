(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{294:function(n,e,t){"use strict";t.r(e);var i=t(10),r=Object(i.a)({},(function(){var n=this,e=n._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[e("h1",{attrs:{id:"若依"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#若依"}},[n._v("#")]),n._v(" 若依")]),n._v(" "),e("p",[e("a",{attrs:{href:"http://doc.ruoyi.vip/ruoyi-vue/",target:"_blank",rel:"noopener noreferrer"}},[n._v("官网"),e("OutboundLink")],1)]),n._v(" "),e("ol",{attrs:{start:"0"}},[e("li",[e("p",[n._v('java 相关：\n@RestController 表示该类是一个控制器，并且返回 json 数据\n@requestMapping("/user") //表示该类中的所有方法都是以/user 为父路径\n@PostMapping("/login") post 请求\n@GetMapping("getInfo") get 请求\n@PostConstruct：加上该注解会在项目启动时执行该方法。比如查询一些表数据存储到 redis\n@Value("${token.expireTime}") 表示从 yml 中获取值\n@bean spring 的注解，用于在配置类中声明一个 bean')])]),n._v(" "),e("li",[e("p",[n._v("redis\nkey + value + 有效期\n取值快，后续可以直接从 redis 取数据，不用每次查询数据库")])]),n._v(" "),e("li",[e("p",[n._v("在线用户展示\n用户登录后会把用户信息存入到 redis 中，直接从 redis 获取即可\nredis 中有效期 30min，即用户 30min 未操作则会自动掉线。\n后续接口请求中，判断 jwt 里的 token 有效时间是否小于 20min，小于则重置有效期即可")])]),n._v(" "),e("li",[e("p",[n._v("在线用户强退\n在 redis 中删除该用户即可，其实就是删除旧的 token，下次请求接口时会返回 401")])]),n._v(" "),e("li",[e("p",[n._v("防止接口重复请求\naxiosCancel 或 时间戳 实现，应用于非 get 请求。(同样需要加个开关控制是否允许接口重复请求，在 config 中加 isRepeatSubmit)")])]),n._v(" "),e("li",[e("p",[n._v("通用文件下载\nfile-saver")])]),n._v(" "),e("li",[e("p",[n._v("通过 IP 获取具体位置信息\n后端通过调用第三方接口获取")])]),n._v(" "),e("li",[e("p",[n._v("JWT 生成时机\n服务端校验账号密码成功后，会生成 token 返回给前端，同时该 token 也会存入 redis,redis 的 key 为 token 的 uuid。\n前端拿到 token 后存入 cookie，后续请求头 header 都会带上该 token\n后端也有个过滤器，每次会解析请求头的 token 信息")])]),n._v(" "),e("li",[e("p",[n._v("springSecurity 认证\nweb 在调用其接口时有个认证、授权的过程，过滤器链形式认证。\n可以重写认证方式，默认是账号密码登录认证")])]),n._v(" "),e("li",[e("p",[n._v("rbac 模型\n基于对角色权限的控制，进而控制用户权限\n页面权限\n按钮权限")])])])])}),[],!1,null,null,null);e.default=r.exports}}]);
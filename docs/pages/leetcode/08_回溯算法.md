# 回溯算法(递归)
## 定义
回溯算法(back tracking)是一种类似尝试算法，按选优条件向前搜索，主要是在搜索尝试过程中寻找问题的解，以达到目标，当发现已不满足求解条件时，就“回溯”返回，尝试别的路径。换句话说，找到一条路往前走，能走就继续往前，不能走就算了，掉头换条路。相对于动态规划，这部分的内容相对于简单些。

回溯的处理思想，和枚举搜索有点类似，通过枚举找到所有满足期望的值。为了有规律地枚举所有的解，可以把问题拆解为多个小问题。每个小问题，我们都会面对一个岔路口，选择一条发现此路不通的时，就往回走，走到另一个岔路口。

关键三点： 1. 节点展开的所有情况  2. 约束节点展开情况  3. 递归结束条件

## 括号生成
数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且**有效的**括号组合。
```
示例：
输入:n = 3
输出：["((()))","(()())","(())()","()(())","()()()"]
```
方法一： 回溯法
``` JS
/**
 * @param {number} n
 * @return {string[]}
 */
var generateParenthesis = function(n) {
    // 输出结果
    let res = []

    function dep (l, r, n, str) { // l :左括号个数， r:右括号个数,  n: 括号对数, str: 括号组合
        // 递归结束条件，长度为2n时说明已结束
        if (str.length === 2* n) {
            res.push(str)
            return
        }
        // 加左括号情况
        if (l < n) {
            dep(l+1, r, n, str + '(')
        }
        // 加右括号情况
        if (l > r) {
            dep(l, r + 1, n, str + ')')
        }
    }
    dep(0, 0, n , '')
    return res
};
```

## 子集
给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。
```
示例：
输入:nums = [1,2,3]
输出：[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]
```

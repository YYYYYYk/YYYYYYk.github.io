# 数字

## 整数反转
```
对一个 32 位的有符号整数 x 进行反转。反转溢出则返回 0
示例：
输入：123 | -123 | 120
输出：321 | -321 | 21
```
方法一： 字符串翻转，最后补充上符号
``` javascript
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
    // 32 位的有符号整数的边界值
    const MAX = Math.pow(2, 31) - 1
    const MIN = -Math.pow(2, 31)
    // 非空判断
    if (typeof x !== 'number') { 
        return; 
    }
    // 识别剩余数字并翻转
    const rest = x > 0 ? String(x).split('').reverse().join('') : String(x).slice(1).split('').reverse().join('')
    // 转化为正常值，区分正负
    const res = x > 0 ? Number(rest) : 0 - Number(rest)
    // 边界判断
    if (res >= MIN && res <= MAX) {
        return res
    }
    return 0
};
``` 
> 代码中 reverse 函数时间复杂度为 O(n) ;n 为整数长度，因此时间复杂度为 **O(n)**, 考虑到32位整数最大长度为 11，即 -2147483648，也可认为是常数时间复杂度 O(1) 。
> 
> 代码中创建临时 String 对象， n 为整数长度，因此空间复杂度为 **O(n)**, 考虑到32位整数最大长度为11，即-2147483648，因此空间复杂度为 O(1) 。

方法二: 类似 欧几里得算法 求解
``` javascript
/**
 * @param {number} x
 * @return {number}
 */
var reverse = function(x) {
  // 获取相应数的绝对值
  let int = Math.abs(x);
  // 32 位的有符号整数的边界值
  const MAX = Math.pow(2, 31) - 1
  const MIN = -Math.pow(2, 31)

  let res =0  
  while (int !== 0) {  // 遍历
    const num = int % 10 // 求余
    res = res * 10 + num // 拼接
    int =  Math.floor(int / 10 ) // 剔除消费部分
  }
  // 边界判断
  if (res >= MIN && res <= MAX) {
      return x > 0 ? res : -res
  }
  return 0
};
```
> 时间复杂度： O(n),代码中使用 for 循环，次数为 n ，即整数的长度，因此时间复杂度为 O(n) 。
>
> 空间复杂度： O(1),算法中只用到常数个变量，因此空间复杂度为 O(1) 。

